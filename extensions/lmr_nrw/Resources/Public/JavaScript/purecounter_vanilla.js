/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
/******/ (function() { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ "./src/javascript/purecounter_vanilla.js":
/*!***********************************************!*\
  !*** ./src/javascript/purecounter_vanilla.js ***!
  \***********************************************/
/***/ (function() {

eval("/** Initial function */\nfunction registerEventListeners() {\n  /** Get all elements with class 'purecounter' */\n  var elements = document.querySelectorAll('.purecounter');\n  /** Get browser Intersection Listener Support */\n  var intersectionSupported = intersectionListenerSupported();\n\n  /** Run animateElements base on Intersection Support */\n  if (intersectionSupported) {\n    var intersectObserver = new IntersectionObserver(animateElements, {\n      \"root\": null,\n      \"rootMargin\": '20px',\n      \"threshold\": 0.5\n    });\n    elements.forEach(function (element) {\n      intersectObserver.observe(element);\n    });\n  } else {\n    if (window.addEventListener) {\n      animateLegacy(elements);\n      window.addEventListener('scroll', function (e) {\n        animateLegacy(elements);\n      }, {\n        \"passive\": true\n      });\n    }\n  }\n}\n\n/** This legacy to make Purecounter use very lightweight & fast */\nfunction animateLegacy(elements) {\n  elements.forEach(function (element) {\n    var config = parseConfig(element);\n    if (config.legacy === true && elementIsInView(element)) {\n      animateElements([element]);\n    }\n  });\n}\n\n/** Main Element Count Animation */\nfunction animateElements(elements, observer) {\n  elements.forEach(function (element) {\n    var elm = element.target || element; // Just make sure which element will be used\n    var elementConfig = parseConfig(elm); // Get config value on that element\n\n    // If duration is less than or equal zero, just format the 'end' value\n    if (elementConfig.duration <= 0) {\n      return elm.innerHTML = formatNumber(elementConfig.end, elementConfig);\n    }\n    if (!observer && !elementIsInView(element) || observer && element.intersectionRatio < 0.5) {\n      var value = elementConfig.start > elementConfig.end ? elementConfig.end : elementConfig.start;\n      return elm.innerHTML = formatNumber(value, elementConfig);\n    }\n\n    // If duration is more than 0, then start the counter\n    setTimeout(function () {\n      return startCounter(elm, elementConfig);\n    }, elementConfig.delay);\n  });\n}\n\n/** This is the the counter method */\nfunction startCounter(element, config) {\n  // First, get the increments step\n  var incrementsPerStep = (config.end - config.start) / (config.duration / config.delay);\n  // Next, set the counter mode (Increment or Decrement)\n  var countMode = 'inc';\n\n  // Set mode to 'decrement' and 'increment step' to minus if start is larger than end\n  if (config.start > config.end) {\n    countMode = 'dec';\n    incrementsPerStep *= -1;\n  }\n\n  // Next, determine the starting value\n  var currentCount = parseValue(config.start);\n  // And then print it's value to the page\n  element.innerHTML = formatNumber(currentCount, config);\n\n  // If the config 'once' is true, then set the 'duration' to 0\n  if (config.once === true) {\n    element.setAttribute('data-purecounter-duration', 0);\n  }\n\n  // Now, start counting with counterWorker using Interval method based on delay\n  var counterWorker = setInterval(function () {\n    // First, determine the next value base on current value, increment value, and count mode\n    var nextNum = nextNumber(currentCount, incrementsPerStep, countMode);\n    // Next, print that value to the page\n    element.innerHTML = formatNumber(nextNum, config);\n    // Now set that value to the current value, because it's already printed\n    currentCount = nextNum;\n\n    // If the value is larger or less than the 'end' (base on mode), then  print the end value and stop the Interval\n    if (currentCount >= config.end && countMode == 'inc' || currentCount <= config.end && countMode == 'dec') {\n      element.innerHTML = formatNumber(config.end, config);\n      clearInterval(counterWorker);\n    }\n  }, config.delay);\n}\n\n/** This function is to generate the element Config */\nfunction parseConfig(element) {\n  // First, we need to declare the base Config\n  // This config will be used if the element doesn't have config\n  var baseConfig = {\n    start: 0,\n    end: 9001,\n    duration: 2000,\n    delay: 10,\n    once: true,\n    decimals: 0,\n    decimalseparatorsymbol: ',',\n    legacy: true,\n    currency: false,\n    currencysymbol: false,\n    separator: false,\n    separatorsymbol: ','\n  };\n\n  // Next, get all 'data-precounter' attributes value. Store to array\n  var configValues = [].filter.call(element.attributes, function (attr) {\n    return /^data-purecounter-/.test(attr.name);\n  });\n\n  // Now, we create element config as an empty object\n  var elementConfig = {};\n\n  // And then, fill the element config based on config values\n  configValues.forEach(function (e) {\n    var name = e.name.replace('data-purecounter-', '').toLowerCase();\n    var value = name == 'duration' ? parseInt(parseValue(e.value) * 1000) : parseValue(e.value);\n    elementConfig[name] = value; // We will get an object\n  });\n\n  // Last marge base config with element config and return it as an object\n  return Object.assign(baseConfig, elementConfig);\n}\n\n/** This function is to get the next number */\nfunction nextNumber(number, steps) {\n  var mode = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 'inc';\n  // First, get the exact value from the number and step (int or float)\n  number = parseValue(number);\n  steps = parseValue(steps);\n\n  // Last, get the next number based on current number, increment step, and count mode\n  // Always return it as float\n  return parseFloat(mode === 'inc' ? number + steps : number - steps);\n}\n\n/** This function is to convert number into currency format */\nfunction convertToCurrencySystem(number, config) {\n  var symbol = config.currencysymbol || \"\",\n    // Set the Currency Symbol (if any)\n    limit = config.decimals || 1,\n    // Set the decimal limit (default is 1)\n    number = Math.abs(Number(number)); // Get the absolute value of number\n\n  // Set the value\n  var value = number >= 1.0e+12 ? \"\".concat((number / 1.0e+12).toFixed(limit), \" T\") // Twelve zeros for Trillions\n  : number >= 1.0e+9 ? \"\".concat((number / 1.0e+9).toFixed(limit), \" B\") // Nine zeros for Billions\n  : number >= 1.0e+6 ? \"\".concat((number / 1.0e+6).toFixed(limit), \" M\") // Six zeros for Millions\n  : number >= 1.0e+3 ? \"\".concat((number / 1.0e+12).toFixed(limit), \" K\") // Three zeros for Thousands\n  : number.toFixed(limit); // If less than 1000, print it's value\n\n  // Apply symbol before the value and return it as string\n  return symbol + value;\n}\n\n/** This function is to get the last formated number */\nfunction applySeparator(value, config) {\n  // If config separator is false, delete all separator\n  if (!config.separator) {\n    return value.replace(new RegExp(/,/gi, 'gi'), '').replace(new RegExp(/\\./gi, 'gi'), '');\n  }\n\n  // If config separator is true, then create separator\n  return value.replace(new RegExp(/,/gi, 'gi'), config.decimalseparatorsymbol).replace(new RegExp(/\\./gi, 'gi'), config.separatorsymbol);\n}\n\n/** This function is to get formated number to be printed in the page */\nfunction formatNumber(number, config) {\n  // This is the configuration for 'toLocaleString' method\n  var strConfig = {\n    minimumFractionDigits: config.decimals,\n    maximumFractionDigits: config.decimals\n  };\n  // Set the number if it using currency, then convert. If doesn't, just parse it as float\n  number = config.currency ? convertToCurrencySystem(number, config) : parseFloat(number);\n\n  // Last, apply the number separator using number as string\n  return applySeparator(number.toLocaleString(undefined, strConfig), config);\n}\n\n/** This function is to get the parsed value */\nfunction parseValue(data) {\n  // If number with dot (.), will be parsed as float\n  if (/^[0-9]+\\.[0-9]+$/.test(data)) {\n    return parseFloat(data);\n  }\n  // If just number, will be parsed as integer\n  if (/^[0-9]+$/.test(data)) {\n    return parseInt(data);\n  }\n  // If it's boolean string, will be parsed as boolean\n  if (/^true|false/i.test(data)) {\n    return /^true/i.test(data);\n  }\n  // Return it's value as default\n  return data;\n}\n\n// This function is to detect the element is in view or not.\nfunction elementIsInView(element) {\n  var top = element.offsetTop;\n  var left = element.offsetLeft;\n  var width = element.offsetWidth;\n  var height = element.offsetHeight;\n  while (element.offsetParent) {\n    element = element.offsetParent;\n    top += element.offsetTop;\n    left += element.offsetLeft;\n  }\n  return top >= window.pageYOffset && left >= window.pageXOffset && top + height <= window.pageYOffset + window.innerHeight && left + width <= window.pageXOffset + window.innerWidth;\n}\n\n/** Just some condition to check browser Intersection Support */\nfunction intersectionListenerSupported() {\n  return 'IntersectionObserver' in window && 'IntersectionObserverEntry' in window && 'intersectionRatio' in window.IntersectionObserverEntry.prototype;\n}\n\n/** Run the initial function */\n(function () {\n  registerEventListeners();\n})();\n\n//# sourceURL=webpack:///./src/javascript/purecounter_vanilla.js?");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module can't be inlined because the eval devtool is used.
/******/ 	var __webpack_exports__ = {};
/******/ 	__webpack_modules__["./src/javascript/purecounter_vanilla.js"]();
/******/ 	
/******/ })()
;